<!DOCTYPE HTML>
<html lang="en" class="light sidebar-visible" dir="ltr">
    <head>
        <!-- Book generated using mdBook -->
        <meta charset="UTF-8">
        <title>LALRPOP&#x27;s lexer generator</title>


        <!-- Custom HTML head -->

        <meta name="description" content="">
        <meta name="viewport" content="width=device-width, initial-scale=1">
        <meta name="theme-color" content="#ffffff">

        <link rel="icon" href="../favicon.svg">
        <link rel="shortcut icon" href="../favicon.png">
        <link rel="stylesheet" href="../css/variables.css">
        <link rel="stylesheet" href="../css/general.css">
        <link rel="stylesheet" href="../css/chrome.css">
        <link rel="stylesheet" href="../css/print.css" media="print">

        <!-- Fonts -->
        <link rel="stylesheet" href="../FontAwesome/css/font-awesome.css">
        <link rel="stylesheet" href="../fonts/fonts.css">

        <!-- Highlight.js Stylesheets -->
        <link rel="stylesheet" id="highlight-css" href="../highlight.css">
        <link rel="stylesheet" id="tomorrow-night-css" href="../tomorrow-night.css">
        <link rel="stylesheet" id="ayu-highlight-css" href="../ayu-highlight.css">

        <!-- Custom theme stylesheets -->

        <!-- MathJax -->
        <script async src="https://cdnjs.cloudflare.com/ajax/libs/mathjax/2.7.1/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>

        <!-- Provide site root and default themes to javascript -->
        <script>
            const path_to_root = "../";
            const default_light_theme = "light";
            const default_dark_theme = "navy";
        </script>
        <!-- Start loading toc.js asap -->
        <script src="../toc.js"></script>
    </head>
    <body>
    <div id="body-container">
        <!-- Work around some values being stored in localStorage wrapped in quotes -->
        <script>
            try {
                let theme = localStorage.getItem('mdbook-theme');
                let sidebar = localStorage.getItem('mdbook-sidebar');

                if (theme.startsWith('"') && theme.endsWith('"')) {
                    localStorage.setItem('mdbook-theme', theme.slice(1, theme.length - 1));
                }

                if (sidebar.startsWith('"') && sidebar.endsWith('"')) {
                    localStorage.setItem('mdbook-sidebar', sidebar.slice(1, sidebar.length - 1));
                }
            } catch (e) { }
        </script>

        <!-- Set the theme before any content is loaded, prevents flash -->
        <script>
            const default_theme = window.matchMedia("(prefers-color-scheme: dark)").matches ? default_dark_theme : default_light_theme;
            let theme;
            try { theme = localStorage.getItem('mdbook-theme'); } catch(e) { }
            if (theme === null || theme === undefined) { theme = default_theme; }
            const html = document.documentElement;
            html.classList.remove('light')
            html.classList.add(theme);
            html.classList.add("js");
        </script>

        <input type="checkbox" id="sidebar-toggle-anchor" class="hidden">

        <!-- Hide / unhide sidebar before it is displayed -->
        <script>
            let sidebar = null;
            const sidebar_toggle = document.getElementById("sidebar-toggle-anchor");
            if (document.body.clientWidth >= 1080) {
                try { sidebar = localStorage.getItem('mdbook-sidebar'); } catch(e) { }
                sidebar = sidebar || 'visible';
            } else {
                sidebar = 'hidden';
            }
            sidebar_toggle.checked = sidebar === 'visible';
            html.classList.remove('sidebar-visible');
            html.classList.add("sidebar-" + sidebar);
        </script>

        <nav id="sidebar" class="sidebar" aria-label="Table of contents">
            <!-- populated by js -->
            <mdbook-sidebar-scrollbox class="sidebar-scrollbox"></mdbook-sidebar-scrollbox>
            <noscript>
                <iframe class="sidebar-iframe-outer" src="../toc.html"></iframe>
            </noscript>
            <div id="sidebar-resize-handle" class="sidebar-resize-handle">
                <div class="sidebar-resize-indicator"></div>
            </div>
        </nav>

        <div id="page-wrapper" class="page-wrapper">

            <div class="page">
                <div id="menu-bar-hover-placeholder"></div>
                <div id="menu-bar" class="menu-bar sticky">
                    <div class="left-buttons">
                        <label id="sidebar-toggle" class="icon-button" for="sidebar-toggle-anchor" title="Toggle Table of Contents" aria-label="Toggle Table of Contents" aria-controls="sidebar">
                            <i class="fa fa-bars"></i>
                        </label>
                        <button id="theme-toggle" class="icon-button" type="button" title="Change theme" aria-label="Change theme" aria-haspopup="true" aria-expanded="false" aria-controls="theme-list">
                            <i class="fa fa-paint-brush"></i>
                        </button>
                        <ul id="theme-list" class="theme-popup" aria-label="Themes" role="menu">
                            <li role="none"><button role="menuitem" class="theme" id="default_theme">Auto</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="light">Light</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="rust">Rust</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="coal">Coal</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="navy">Navy</button></li>
                            <li role="none"><button role="menuitem" class="theme" id="ayu">Ayu</button></li>
                        </ul>
                        <button id="search-toggle" class="icon-button" type="button" title="Search. (Shortkey: s)" aria-label="Toggle Searchbar" aria-expanded="false" aria-keyshortcuts="S" aria-controls="searchbar">
                            <i class="fa fa-search"></i>
                        </button>
                    </div>

                    <h1 class="menu-title"></h1>

                    <div class="right-buttons">
                        <a href="../print.html" title="Print this book" aria-label="Print this book">
                            <i id="print-button" class="fa fa-print"></i>
                        </a>

                    </div>
                </div>

                <div id="search-wrapper" class="hidden">
                    <form id="searchbar-outer" class="searchbar-outer">
                        <input type="search" id="searchbar" name="searchbar" placeholder="Search this book ..." aria-controls="searchresults-outer" aria-describedby="searchresults-header">
                    </form>
                    <div id="searchresults-outer" class="searchresults-outer hidden">
                        <div id="searchresults-header" class="searchresults-header"></div>
                        <ul id="searchresults">
                        </ul>
                    </div>
                </div>

                <!-- Apply ARIA attributes after the sidebar and the sidebar toggle button are added to the DOM -->
                <script>
                    document.getElementById('sidebar-toggle').setAttribute('aria-expanded', sidebar === 'visible');
                    document.getElementById('sidebar').setAttribute('aria-hidden', sidebar !== 'visible');
                    Array.from(document.querySelectorAll('#sidebar a')).forEach(function(link) {
                        link.setAttribute('tabIndex', sidebar === 'visible' ? 0 : -1);
                    });
                </script>

                <div id="content" class="content">
                    <main>
                        <h1 id="lalrpops-lexer-generator"><a class="header" href="#lalrpops-lexer-generator">LALRPOP's lexer generator</a></h1>
<p>This example dives a bit deeper into how LALRPOP works. In particular,
it dives into the meaning of those strings and regular expression that
we used in the previous tutorial, and how they are used to process the
input string (a process which you can control). This first step of
breaking up the input using regular expressions is often called
<strong>lexing</strong> or <strong>tokenizing</strong>.</p>
<p>If you're comfortable with the idea of a lexer or tokenizer, you may
wish to skip ahead to the <a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator3.lalrpop">calculator3</a> example, which covers
parsing bigger expressions, and come back here only when you find you
want more control. You may also be interested in the
<a href="index.html">tutorial on writing a custom lexer</a>.</p>
<h2 id="terminals-vs-nonterminals"><a class="header" href="#terminals-vs-nonterminals">Terminals vs nonterminals</a></h2>
<p>You may have noticed that our grammar included two distinct kinds of
symbols. There were the nonterminals, <code>Term</code> and <code>Num</code>, which we
defined by specifying a series of symbols that they must match, along
with some action code that should execute once they have matched:</p>
<pre><code class="language-text">   Num: i32 = r"[0-9]+" =&gt; i32::from_str(&lt;&gt;).unwrap();
// ~~~  ~~~   ~~~~~~~~~    ~~~~~~~~~~~~~~~~~~~~~~~~~~
// |    |     |                Action code
// |    |     Symbol(s) that should match
// |    Return type
// Name of nonterminal
</code></pre>
<p>But there are also <strong>terminals</strong>, which consist of the string literals
and regular expressions sprinkled throughout the grammar. (Terminals
are also often called <strong>tokens</strong>, and I will use the terms
interchangeably.)</p>
<p>This distinction between terminals and nonterminals is very important
to how LALRPOP works. In fact, when LALRPOP generates a parser, it
always works in a two-phase process. The first phase is called the
<strong>lexer</strong> or <strong>tokenizer</strong>. It has the job of figuring out the
sequence of <strong>terminals</strong>: so basically it analyzes the raw characters
of your text and breaks them into a series of terminals. It does this
without having any idea about your grammar or where you are in your
grammar. Next, the parser proper is a bit of code that looks at this
stream of tokens and figures out which nonterminals apply:</p>
<pre><code class="language-text">        +-------------------+    +---------------------+
Text -&gt; | Lexer             | -&gt; | Parser              |
        |                   |    |                     |
        | Applies regex to  |    | Consumes terminals, |
        | produce terminals |    | executes your code  |
        +-------------------+    | as it recognizes    |
                                 | nonterminals        |
                                 +---------------------+
</code></pre>
<p>LALRPOP's default lexer is based on regular expressions. By default,
it works by extracting all the terminals (e.g., <code>"("</code> or <code>r"\d+"</code>)
from your grammar and compiling them into one big list. At runtime, it
will walk over the string and, at each point, find the longest match
from the literals and regular expressions in your grammar and produces
one of those. As an example, let's look again at our example grammar:</p>
<pre><code class="language-lalrpop">pub Term: i32 = {
    &lt;n:Num&gt; =&gt; n,
    "(" &lt;t:Term&gt; ")" =&gt; t,
};

Num: i32 = &lt;s:r"[0-9]+"&gt; =&gt; i32::from_str(s).unwrap();
</code></pre>
<p>This grammar in fact contains three terminals:</p>
<ul>
<li><code>"("</code> -- a string literal, which must match exactly</li>
<li><code>")"</code> -- a string literal, which must match exactly</li>
<li><code>r"[0-9]+"</code> -- a regular expression</li>
</ul>
<p>When we generate a lexer, it is effectively going to be checking for
each of these three terminals in a loop, sort of like this pseudocode:</p>
<pre><code class="language-text">let mut i = 0; // index into string
loop {
    skip whitespace; // we do this implicitly, at least by default
    if (data at index i is "(") { produce "("; }
    else if (data at index i is ")") { produce ")"; }
    else if (data at index i matches regex "[0-9]+") { produce r"[0-9]+"; }
}
</code></pre>
<p>Note that this has nothing to do with your grammar. For example, the tokenizer
would happily tokenize a string like this one, which doesn't fit our grammar:</p>
<pre><code class="language-text">  (  22   44  )     )
  ^  ^^   ^^  ^     ^
  |  |    |   |     ")" terminal
  |  |    |   |
  |  |    |   ")" terminal
  |  +----+
  |  |
  |  2 r"[0-9]+" terminals
  |
  "(" terminal
</code></pre>
<p>When these tokens are fed into the <strong>parser</strong>, it would notice that we
have one left paren but then two numbers (<code>r"[0-9]+"</code> terminals), and
hence report an error.</p>
<h2 id="precedence-of-fixed-strings"><a class="header" href="#precedence-of-fixed-strings">Precedence of fixed strings</a></h2>
<p>Terminals in LALRPOP can be specified (by default) in two ways. As a
fixed string (like <code>"("</code>) or a regular expression (like
<code>r[0-9]+</code>). There is actually an important difference: if, at some
point in the input, both a fixed string <strong>and</strong> a regular expression
could match, LALRPOP gives the fixed string precedence. To demonstrate
this, let's modify our parser. If you recall, the current parser
parses parenthesized numbers, producing a <code>i32</code>. We're going to modify
if to produce a <strong>string</strong>, and we'll add an "easter egg" so that <code>22</code>
(or <code>(22)</code>, <code>((22))</code>, etc) produces the string <code>"Twenty-two"</code>:</p>
<pre><code class="language-lalrpop">pub Term = {
    Num,
    "(" &lt;Term&gt; ")",
    "22" =&gt; "Twenty-two!".to_string(),
};

Num: String = r"[0-9]+" =&gt; &lt;&gt;.to_string();
</code></pre>
<p>If we write some simple unit tests, we can see that in fact an input
of <code>22</code> has matched the string literal. Interestingly, the input <code>222</code>
matches the regular expression instead; this is because LALRPOP
prefers to find the <strong>longest</strong> match first. After that, if there are
two matches of equal length, it prefers the fixed string:</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn calculator2b() {
    let result = calculator2b::TermParser::new().parse("33").unwrap();
    assert_eq!(result, "33");

    let result = calculator2b::TermParser::new().parse("(22)").unwrap();
    assert_eq!(result, "Twenty-two!");

    let result = calculator2b::TermParser::new().parse("(222)").unwrap();
    assert_eq!(result, "222");
}
<span class="boring">}</span></code></pre></pre>
<h2 id="ambiguities-between-regular-expressions"><a class="header" href="#ambiguities-between-regular-expressions">Ambiguities between regular expressions</a></h2>
<p>In the previous section, we saw that fixed strings have precedence
over regular expressions. But what if we have two regular expressions
that can match the same input? Which one wins? For example, consider
this variation of the grammar above, where we also try to support
parenthesized <strong>identifiers</strong> like <code>((foo22))</code>:</p>
<pre><code class="language-lalrpop">pub Term = {
    Num,
    "(" &lt;Term&gt; ")",
    "22" =&gt; format!("Twenty-two!"),
    r"\w+" =&gt; format!("Id({})", &lt;&gt;), // &lt;-- we added this
};

Num: String = r"[0-9]+" =&gt; &lt;&gt;.to_string();
</code></pre>
<p>Here I've written the regular expression <code>r\w+</code>. However, if you check
out the <a href="https://docs.rs/regex">docs for regex</a>, you'll see that <code>\w</code>
is defined to match alphabetic characters but also digits. So there
is actually an ambiguity here: if we have something like <code>123</code>, it
could be considered to match either <code>r"[0-9]+"</code> <strong>or</strong> <code>r"\w+"</code>. If
you try this grammar, you'll find that LALRPOP helpfully reports an
error:</p>
<pre><code class="language-text">error: ambiguity detected between the terminal `r#"\w+"#` and the terminal `r#"[0-9]+"#`

      r"\w+" =&gt; &lt;&gt;.to_string(),
      ~~~~~~
</code></pre>
<p>There are various ways to fix this. We might try adjusting our regular
expression so that the first character cannot be a number, so perhaps
something like <code>r"[[:alpha:]]\w*"</code>. This will work, but it actually
matches something different than what we had before (e.g., <code>123foo</code>
will not be considered to match, for better or worse). And anyway it's
not always convenient to make your regular expressions completely
disjoint like that. Another option is to use a <code>match</code> declaration,
which lets you control the precedence between regular expressions.</p>
<h2 id="simple-match-declarations"><a class="header" href="#simple-match-declarations">Simple <code>match</code> declarations</a></h2>
<p>A <code>match</code> declaration lets you explicitly give the precedence between
terminals. In its simplest form, it consists of just ordering regular
expressions and string literals into groups, with the higher
precedence items coming first. So, for example, we could resolve
our conflict above by giving <code>r"[0-9]+"</code> <strong>precedence</strong> over <code>r"\w+"</code>,
thus saying that if something can be lexed as a number, we'll do that,
and otherwise consider it to be an identifier.</p>
<pre><code class="language-lalrpop">match {
    r"[0-9]+"
} else {
    r"\w+",
    _
}
</code></pre>
<p>Here the match contains two levels; each level can have more than one
item in it. The top-level contains only <code>r"[0-9]+"</code>, which means that this
regular expression is given highest priority. The next level contains
<code>r\w+</code>, so that will match afterwards.</p>
<p>The final <code>_</code> indicates that other string literals and regular
expressions that appear elsewhere in the grammar (e.g., <code>"("</code> or
<code>"22"</code>) should be added into that final level of precedence (without
an <code>_</code>, it is illegal to use a terminal that does not appear in the
match declaration).</p>
<p>If we add this <code>match</code> section into our example, we'll find that it
compiles, but it doesn't work exactly like we wanted. Let's update our
unit test a bit to include some identifier examples::</p>
<pre><pre class="playground"><code class="language-rust"><span class="boring">#![allow(unused)]
</span><span class="boring">fn main() {
</span>#[test]
fn calculator2b() {
    // These will all work:

    let result = calculator2b::TermParser::new().parse("33").unwrap();
    assert_eq!(result, "33");

    let result = calculator2b::TermParser::new().parse("foo33").unwrap();
    assert_eq!(result, "Id(foo33)");

    let result = calculator2b::TermParser::new().parse("(foo33)").unwrap();
    assert_eq!(result, "Id(foo33)");

    // This one will fail:

    let result = calculator2b::TermParser::new().parse("(22)").unwrap();
    assert_eq!(result, "Twenty-two!");
}
<span class="boring">}</span></code></pre></pre>
<p>The problem comes about when we parse <code>22</code>. Before, the fixed string
<code>22</code> got precedence, but with the new match declaration, we've
explicitly stated that the regular expression <code>r"[0-9]+"</code> has full
precedence. Since the <code>22</code> is not listed explicitly, it gets added at
the last level, where the <code>_</code> appears. We can fix this by adjusting
our <code>match</code> to mention <code>22</code> explicitly:</p>
<pre><code class="language-lalrpop">match {
    r"[0-9]+",
    "22"
} else {
    r"\w+",
    _
}
</code></pre>
<p>This raises the interesting question of what the precedence is <strong>within</strong>
a match rung -- after all, both the regex and <code>"22"</code> can match the same
string. The answer is that within a match rung, fixed literals get precedence
over regular expressions, just as before, and all regular expressions
must not overlap.</p>
<p>With this new <code>match</code> declaration, we will find that our tests all pass.</p>
<h2 id="renaming-match-declarations"><a class="header" href="#renaming-match-declarations">Renaming <code>match</code> declarations</a></h2>
<p>There is one final twist before we reach the
<a href="https://github.com/lalrpop/lalrpop/blob/master/doc/calculator/src/calculator2b.lalrpop">final version of our example</a> that you will find in the
repository. We can also use <code>match</code> declarations to give names to regular
expressions, so that we don't have to type them directly in our
grammar. For example, maybe instead of writing <code>r"\w+"</code>, we would
prefer to write <code>ID</code>. We could do that by modifying the match declaration like
so:</p>
<pre><code class="language-lalrpop">match {
    r"[0-9]+",
    "22"
} else {
    r"\w+" =&gt; ID, // &lt;-- give a name here
    _
}
</code></pre>
<p>And then adjusting the definition of <code>Term</code> to reference <code>ID</code> instead:</p>
<pre><code class="language-lalrpop">pub Term = {
    Num,
    "(" &lt;Term&gt; ")",
    "22" =&gt; "Twenty-two!".to_string(),
    ID =&gt; format!("Id({})", &lt;&gt;), // &lt;-- changed this
};
</code></pre>
<p>In fact, the match declaration can map a regular expression to any
kind of symbol you want (i.e., you can also map to a string literal or
even a regular expression). Whatever symbol appears after the <code>=&gt;</code> is
what you should use in your grammar. As an example, some languages
have case-insensitive keywords; if you wanted to write <code>"BEGIN"</code> in the
grammar itself, but have that map to a regular expression in the lexer, you
might write:</p>
<pre><code class="language-lalrpop">match {
    r"(?i)begin" =&gt; "BEGIN",
    ...
}
</code></pre>
<p>And now any reference in your grammar to <code>"BEGIN"</code> will actually match
any capitalization.</p>
<h2 id="customizing-skipping-between-tokens"><a class="header" href="#customizing-skipping-between-tokens">Customizing skipping between tokens</a></h2>
<p>If we want to support comments we will need to skip more than just whitespace
in our lexer. To this end <code>ignore patterns</code> can be specified.</p>
<pre><code class="language-lalrpop">match {
    r"\s*" =&gt; { }, // The default whitespace skipping is disabled if an `ignore pattern` is specified
    r"//[^\n\r]*[\n\r]*" =&gt; { }, // Skip `// comments`
    r"/\*[^*]*\*+(?:[^/*][^*]*\*+)*/" =&gt; { },  // Skip `/* comments */`
}
</code></pre>
<h2 id="unicode-compatibility"><a class="header" href="#unicode-compatibility">Unicode compatibility</a></h2>
<p>LALRPOP is capable of lexing tokens that match the full unicode character set,
or those that just match ASCII.  If you need unicode matching, you should
enable <code>features = [ "unicode" ]</code> in your Cargo.toml.  Because lexing unicode
requires loading the full unicode character set, enabling this feature will
increase binary size, so you may wish to avoid it if you do not need unicode
support.</p>
<p>It's important to note that <a href="https://docs.rs/regex/latest/regex/#perl-character-classes-unicode-friendly">certain character classes</a> from perl
regex extensions are "unicode friendly", and require unicode support.  For
example, "\s" matches unicode whitespace characters, not just ASCII ones, and
likewise "\d" matches unicode digits (such as numerals in non-latin character
sets).  If you use those patterns in your lexer, you will require unicode.</p>
<p>You may wish to match only the ASCII subset of these characters, in which case,
you can use the ASCII only character classes described <a href="https://docs.rs/regex/latest/regex/#ascii-character-classes">here</a> as
substitutes and avoid adding unicode dependencies.</p>

                    </main>

                    <nav class="nav-wrapper" aria-label="Page navigation">
                        <!-- Mobile navigation buttons -->
                            <a rel="prev" href="../lexer_tutorial/index.html" class="mobile-nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                                <i class="fa fa-angle-left"></i>
                            </a>

                            <a rel="next prefetch" href="../lexer_tutorial/002_raw_delimited_content.html" class="mobile-nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                                <i class="fa fa-angle-right"></i>
                            </a>

                        <div style="clear: both"></div>
                    </nav>
                </div>
            </div>

            <nav class="nav-wide-wrapper" aria-label="Page navigation">
                    <a rel="prev" href="../lexer_tutorial/index.html" class="nav-chapters previous" title="Previous chapter" aria-label="Previous chapter" aria-keyshortcuts="Left">
                        <i class="fa fa-angle-left"></i>
                    </a>

                    <a rel="next prefetch" href="../lexer_tutorial/002_raw_delimited_content.html" class="nav-chapters next" title="Next chapter" aria-label="Next chapter" aria-keyshortcuts="Right">
                        <i class="fa fa-angle-right"></i>
                    </a>
            </nav>

        </div>




        <script>
            window.playground_copyable = true;
        </script>

        <script src="../ace.js"></script>
        <script src="../editor.js"></script>
        <script src="../mode-rust.js"></script>
        <script src="../theme-dawn.js"></script>
        <script src="../theme-tomorrow_night.js"></script>

        <script src="../elasticlunr.min.js"></script>
        <script src="../mark.min.js"></script>
        <script src="../searcher.js"></script>

        <script src="../clipboard.min.js"></script>
        <script src="../highlight.js"></script>
        <script src="../book.js"></script>

        <!-- Custom JS scripts -->


    </div>
    </body>
</html>
