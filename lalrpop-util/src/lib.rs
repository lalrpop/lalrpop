use std::collections::HashMap;

#[derive(Debug)]
pub enum ParseError<L,T,E> {
    /// Generated by the parser when it encounters a token (or EOF) it did not
    /// expect.
    InvalidToken {
        location: L
    },

    /// Generated by the parser when it encounters a token (or EOF) it did not
    /// expect.
    UnrecognizedToken {
        /// If this is `Some`, then an unexpected token of type `T`
        /// was observed, with a span given by the two `L` values. If
        /// this is `None`, then EOF was observed when it was not
        /// expected.
        token: Option<(L, T, L)>,

        /// The set of expected tokens: these names are taken from the
        /// grammar and hence may not necessarily be suitable for
        /// presenting to the user.
        expected: Vec<String>
    },

    /// Generated by the parser when it encounters additional,
    /// unexpected tokens.
    ExtraToken {
        token: (L, T, L),
    },

    /// Custom error type.
    User {
        error: E,
    },
}

pub struct Machine<'table> {
    actions: &'table [&'table [i32]],
    gotos: &'table [&'table [u32]],
    terminal_bits: HashMap<String, usize>,
    state_stack: Vec<u32>,
}

enum Action {
    Shift(u32),
    Reduce(u32),
}

impl<'table> Machine<'table> {
    pub fn new(actions: &'table [&'table [i32]], gotos: &'table [&'table [u32]]) -> Machine<'table> {
        Machine { actions: actions,
                  gotos: gotos,
                  terminal_bits: HashMap::new(),
                  state_stack: Vec::new()}
    }

    fn get_action(&self, state: usize, terminal: &str) -> Option<Action> {
        // TODO propagate error
        let terminal_index = if let Some(i) = self.terminal_bits.get(terminal) {
            *i
        } else {
            return None;
        };

        let a = self.actions[state][terminal_index];

        if a == 0 {
            None
        } else if a > 0 {
            Some(Action::Shift(a as u32 - 1))
        } else {
            Some(Action::Reduce(((-1) * a) as u32 + 1))
        }
    }

    fn top_state(&self) -> usize {
        *self.state_stack.last().unwrap() as usize
    }

    fn execute_partial<TOKENS>(&mut self, mut tokens: TOKENS)
                               -> Result<(), ()>
        where TOKENS: Iterator<Item=String>
    {
        assert!(self.state_stack.is_empty());

        self.state_stack.push(0);

        let mut token = tokens.next();
        while let Some(terminal) = token {
            let state = self.top_state();

            // check whether we can shift this token
            match self.get_action(state, &terminal) {
                None => { panic!("Error"); }
                Some(Action::Shift(next_index)) => {
                    self.state_stack.push(next_index);
                    token = tokens.next();
                }

                Some(Action::Reduce(index)) => {
                    token = Some(terminal);
                }
            }
        }
        Ok(())
    }
}
